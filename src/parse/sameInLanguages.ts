import {
  IntelligibilityLevel,
  SlavicLanguage,
  SlavicRegionalTag,
} from '../types';
import { IntelligibilityReport } from '../core/IntelligibilityReport';

const TOKEN_REGEXP = /(!)?(!?[a-z]+)([+*?~#-])?/;

export default function parseSameInLanguages(
  encoded: string,
  legacy = false,
): IntelligibilityReport {
  const str = legacy ? cutBeforeParentheses(encoded) : encoded;
  return parseIntellgibilityFragment(str.trim(), legacy);
}

function cutBeforeParentheses(str: string): string {
  const leftBracketPos = str.indexOf('(');
  const beforeParentheses =
    leftBracketPos >= 0 ? str.slice(0, leftBracketPos) : str;

  return beforeParentheses;
}

function parseIntellgibilityFragment(
  encoded: string,
  legacy: boolean,
): IntelligibilityReport {
  const result = new IntelligibilityReport();
  if (!encoded) {
    return result;
  }

  const tokens = encoded.split(/\s+/);
  for (const token of tokens) {
    const match = TOKEN_REGEXP.exec(token);
    if (!match) {
      continue;
    }

    const [, auto, rtag, level] = match;
    for (const lang of expandRegionalTag(rtag as SlavicRegionalTag, legacy)) {
      result[lang].level =
        legacy && !level ? IntelligibilityLevel.DirectMatch : parseLevel(level);
      result[lang].autogenerated = legacy || auto === '!';
    }
  }

  return result;
}

function parseLevel(encodedIntelligibility: string): IntelligibilityLevel {
  switch (encodedIntelligibility) {
    case '+':
      return IntelligibilityLevel.DirectMatch;
    case '*':
      return IntelligibilityLevel.HelperMatch;
    case '?':
      return IntelligibilityLevel.AmbiguousDirectMatch;
    case '~':
      return IntelligibilityLevel.AmbiguousHelperMatch;
    case '#':
      return IntelligibilityLevel.FalseFriend;
    case '-':
      return IntelligibilityLevel.NoMatch;
    default:
      return IntelligibilityLevel.Unknown;
  }
}

function expandRegionalTag(
  tag: SlavicRegionalTag,
  legacy: boolean,
): SlavicLanguage[] {
  const L = SlavicLanguage;

  switch (tag) {
    case 'v': // Eastern Slavic langauges
      return [L.Russian, L.Belarusian, L.Ukrainian];
    case 'ru':
      return [L.Russian];
    case 'be':
      return [L.Belarusian];
    case 'uk':
      return [L.Ukrainian];
    case 'rue':
      return [L.Rusyn];
    case 'cu':
      return [L.ChurchSlavonic];
    case 'ub':
      return [L.Ukrainian, L.Belarusian];

    case 'z': // Western Slavic languages
      return [L.Polish, L.Slovak, L.Czech];
    case 'pl':
      return [L.Polish];
    case 'sk':
      return [L.Slovak];
    case 'cz':
      return [L.Czech];
    case 'cs':
      return legacy ? [L.Czech, L.Slovak] : [L.Czech];
    case 'csb':
      return [L.Kashubian];
    case 'szl':
      return [L.Silesian];
    case 'dsb':
      return [L.LowerSorbian];
    case 'hsb':
      return [L.UpperSorbian];
    case 'sb':
      return [L.LowerSorbian, L.UpperSorbian];

    case 'j': // Southern Slavic Languages
      return [
        L.Bulgarian,
        L.Macedonian,
        L.Bosnian,
        L.Croatian,
        L.Montenegrin,
        L.Serbian,
        L.Slovenian,
      ];
    case 'bg':
      return [L.Bulgarian];
    case 'mk':
      return [L.Macedonian];
    case 'bs':
      return [L.Bosnian];
    case 'hr':
      return [L.Croatian];
    case 'cnr':
      return [L.Montenegrin];
    case 'sr':
      return [L.Serbian];
    case 'sl':
      return [L.Slovenian];
    case 'bm':
      return [L.Bulgarian, L.Macedonian];
    case 'yu':
      return [L.Slovenian, L.Croatian, L.Serbian, L.Bosnian, L.Montenegrin];
    case 'sh':
      return [L.Serbian, L.Croatian, L.Bosnian, L.Montenegrin];
    default:
      return [];
  }
}
