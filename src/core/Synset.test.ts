import { Synset } from './Synset';
import { LemmaGroup } from './LemmaGroup';
import { Lemma } from './Lemma';
import { Annotation } from './Annotation';

describe('Synset', () => {
  describe('when created', () => {
    describe('with no options', () => {
      it('should contain no groups', () => {
        expect(anEmptySynset().groups).toEqual([]);
      });

      it('should report itself as autogenerated', () => {
        expect(anEmptySynset().meta.autogenerated).toBe(true);
      });

      it('should not report itself as debatable', () => {
        expect(anEmptySynset().meta.debatable).toBe(false);
      });

      it('should be empty', () => {
        expect(anEmptySynset().empty).toBe(true);
      });
    });

    describe('with options', () => {
      it('should contain those groups', () => {
        const { synset, groups } = aComplexSynset();
        expect(synset.groups).toEqual(groups);
      });

      it('should contain meta.autogenerated', () => {
        const { synset, meta } = aComplexSynset();
        expect(synset.meta.autogenerated).toBe(meta.autogenerated);
      });

      it('should contain meta.debatable', () => {
        const { synset, meta } = aComplexSynset();
        expect(synset.meta.debatable).toBe(meta.debatable);
      });

      it('should be not empty', () => {
        const { synset } = aComplexSynset();
        expect(synset.empty).toBe(false);
      });
    });
  });

  describe('.add()', () => {
    it('should add a string', () => {
      const synset = anEmptySynset();
      expect(synset.add('value').toString()).toBe('!value');
    });

    it('should add a string array', () => {
      const synset = anEmptySynset();
      expect(synset.add(['value1', 'value2']).toString()).toBe(
        '!value1, value2',
      );
      expect(synset.groups.length).toBe(1);
    });

    it('should add a string array (with commas)', () => {
      const synset = anEmptySynset();
      expect(synset.add(['value1, value2', 'value3']).toString()).toBe(
        '!value1, value2; value3',
      );
      expect(synset.groups.length).toBe(1);
    });

    it('should add a lemma', () => {
      const synset = anEmptySynset();
      const annotation = new Annotation({ value: 'some annotation' });
      const lemma = new Lemma({ value: 'value', annotations: [annotation] });

      expect(synset.add(lemma).toString()).toBe('!value (some annotation)');
    });

    it('should add an array of lemmas', () => {
      const synset = anEmptySynset();
      const annotation = new Annotation({ value: 'annot.' });
      const lemma1 = new Lemma({ value: 'value', annotations: [annotation] });
      const lemma2 = new Lemma('value2');

      expect(synset.add([lemma1]).add([lemma2]).toString()).toBe(
        '!value (annot.), value2',
      );
    });

    it('should add a lemma group', () => {
      const synset = anEmptySynset();
      const group = new LemmaGroup([new Lemma('value')]);

      expect(synset.add(group).toString()).toBe('!value');
    });

    it('should add an array of lemma groups', () => {
      const synset = anEmptySynset();
      const group1 = new LemmaGroup([new Lemma('value1')]);
      const group2 = new LemmaGroup([new Lemma('value2')]);

      expect(synset.add([group1, group2]).toString()).toBe('!value1; value2');
      expect(synset.groups.length).toBe(2);
    });

    it('should throw an attempt to pass something else', () => {
      const synset = anEmptySynset();
      const smth = {} as any;
      expect(() => synset.add(smth)).toThrowError(/Cannot add/);
    });
  });

  describe('.clear()', () => {
    it('should mutate and clear groups', () => {
      const synset = anEmptySynset().add('something');
      synset.clear();
      expect(synset.toString()).toBe('!');
    });
  });

  describe('.clone()', () => {
    it('should deep clone the synset', () => {
      const synset = anEmptySynset().add(
        new Lemma({
          value: 'hello',
          annotations: [
            new Annotation({
              value: 'greeting',
            }),
          ],
        }),
      );

      const clone = synset.clone();

      expect(clone.toString()).toBe('!hello (greeting)');
      expect(clone.toString()).toBe(synset.toString());
      expect(clone).not.toBe(synset);
      expect(clone.groups).not.toBe(synset.groups);
      expect(clone.groups[0]).not.toBe(synset.groups[0]);
      expect(clone.groups[0].lemmas).not.toBe(synset.groups[0].lemmas);
      expect(clone.groups[0].lemmas[0]).not.toBe(synset.groups[0].lemmas[0]);
      expect(clone.groups[0].lemmas[0].annotations).not.toBe(
        synset.groups[0].lemmas[0].annotations,
      );
      expect(clone.groups[0].lemmas[0].annotations[0]).not.toBe(
        synset.groups[0].lemmas[0].annotations[0],
      );
    });
  });

  describe('.union()', () => {
    it('should create a new synset with all the values', () => {
      const synset1 = anEmptySynset().add(['a', 'b']);
      const synset2 = anEmptySynset().add(['b', 'c']);
      const union = synset1.union(synset2);

      expect(union).not.toBe(synset1);
      expect(union).not.toBe(synset2);
      expect(union.toString()).toBe('!a, b, c');
    });

    it('should always take the worst-case metadata', () => {
      const synset1 = anEmptySynset().add(['a', 'b']);
      const synset2 = anEmptySynset();
      synset1.meta.autogenerated = false;
      synset1.meta.debatable = true;

      const union = synset1.union(synset2);
      expect(union.toString()).toBe('#!a, b');
    });
  });

  describe('.difference()', () => {
    it('should create a new synset with values missing in the other one', () => {
      const synset1 = anEmptySynset().add(['a', 'b']);
      const synset2 = anEmptySynset().add(['b', 'c']);
      const difference = synset1.difference(synset2);

      expect(difference).not.toBe(synset1);
      expect(difference).not.toBe(synset2);
      expect(difference.toString()).toBe('!a');
    });

    it('should always take the worst-case metadata', () => {
      const synset1 = anEmptySynset().add(['a', 'b']);
      const synset2 = anEmptySynset();
      synset1.meta.autogenerated = false;
      synset1.meta.debatable = true;

      const union = synset1.difference(synset2);
      expect(union.toString()).toBe('#!a, b');
    });
  });

  describe('.intersection()', () => {
    it('should return an empty synset if there is no intersection', () => {
      const s1 = anEmptySynset().add('lemma1');
      const s2 = anEmptySynset().add('lemma2');

      expect(s1.intersection(s2).toString()).toBe('!');
    });

    it('should return a non-empty synset if there is an intersection', () => {
      const s1 = anEmptySynset().add(['this', 'lemma']);
      const s2 = anEmptySynset().add(['that', 'lemma']);

      s1.meta.autogenerated = s2.meta.autogenerated = false;
      s2.meta.debatable = true;

      expect(s1.intersection(s2).toString()).toBe('#lemma');
    });
  });

  describe('.lemmas()', () => {
    it('should iterate over lemmas across groups', () => {
      const { lemmas, synset } = aComplexSynset();
      expect([...synset.lemmas()]).toEqual(lemmas);
    });
  });

  describe('.annotations()', () => {
    it('should iterate over annotations across all lemmas', () => {
      const { annotations, synset } = aComplexSynset();
      expect([...synset.annotations()]).toEqual(annotations);
    });
  });

  describe('when stringified', () => {
    it('should prepend ! if it is autogenerated', () => {
      const { synset } = aComplexSynset();
      synset.meta.autogenerated = true;
      synset.meta.debatable = false;

      expect(`${synset}`).toMatch(/^!/);
    });

    it('should not prepend ! if it is not autogenerated', () => {
      const { synset } = aComplexSynset();
      synset.meta.autogenerated = false;
      synset.meta.debatable = false;

      expect(`${synset}`).not.toMatch(/^!/);
    });

    it('should prepend # if it is debatable', () => {
      const { synset } = aComplexSynset();
      synset.meta.debatable = true;
      synset.meta.autogenerated = false;

      expect(`${synset}`).toMatch(/^#/);
    });

    it('should not prepend # if it is not debatable', () => {
      const { synset } = aComplexSynset();
      synset.meta.debatable = false;
      synset.meta.autogenerated = false;

      expect(`${synset}`).not.toMatch(/^#/);
    });

    it('should prepend both !# if it is autogenerated and debatable', () => {
      const { synset } = aComplexSynset();
      synset.meta.autogenerated = true;
      synset.meta.debatable = true;

      expect(`${synset}`).toMatch(/^#!/);
    });

    it('should separate groups with (;) and lemmas with (,) inside', () => {
      const { synset, lemmas, annotations } = aComplexSynset();
      const [l1, l2, l3] = lemmas.map((l) => l.value);
      const [a1, a2] = annotations.map((a) => a.value);

      synset.meta.autogenerated = false;
      synset.meta.debatable = false;

      expect(`${synset}`).toBe(`${l1}, ${l2} (${a1}); ${l3} (${a2})`);
    });
  });

  function aComplexSynset() {
    const annotation1 = new Annotation({ value: 'obsolete' });
    const annotation2 = new Annotation({ value: 'medical' });
    const lemma1 = new Lemma({ value: 'you' });
    const lemma2 = new Lemma({ value: 'thou', annotations: [annotation1] });
    const lemma3 = new Lemma({ value: 'lupus', annotations: [annotation2] });
    const groups = [
      new LemmaGroup({ lemmas: [lemma1, lemma2] }),
      new LemmaGroup({ lemmas: [lemma3] }),
    ];

    const autogenerated = false;
    const debatable = true;

    return {
      synset: new Synset({ groups, debatable, autogenerated }),
      meta: {
        autogenerated,
        debatable,
      },
      groups,
      lemmas: [lemma1, lemma2, lemma3],
      annotations: [annotation1, annotation2],
    };
  }

  function anEmptySynset() {
    return new Synset();
  }
});
